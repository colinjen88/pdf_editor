<button onclick="openApiModal()"
    class="bg-vibe-surface hover:bg-indigo-600/20 text-sm px-4 py-2 rounded-lg border border-vibe-border transition-colors flex items-center gap-2 shadow">
    <i class="ph ph-share-network text-lg"></i>
    <span>API/協作</span>
</button>
<!-- API/協作視窗 -->
<div id="api-modal" class="fixed inset-0 z-[112] bg-black/30 hidden flex items-center justify-center">
    <div class="bg-vibe-surface rounded-2xl shadow-lg border border-vibe-border p-8 flex flex-col gap-6 min-w-[420px]">
        <h2 class="text-xl font-semibold mb-2">API 與協作</h2>
        <div class="flex flex-col gap-3">
            <label class="flex items-center gap-2"><input type="checkbox" id="api-export" class="accent-indigo-500">
                匯出PDF至API</label>
            <label class="flex items-center gap-2"><input type="checkbox" id="api-collab" class="accent-green-500">
                產生協作連結</label>
            <label class="flex items-center gap-2"><input type="checkbox" id="api-annotate" class="accent-amber-500">
                多人註解協作</label>
        </div>
        <div class="flex gap-4 mt-4">
            <button id="api-confirm" class="px-5 py-2 rounded bg-indigo-500 text-white font-medium">執行</button>
            <button onclick="closeApiModal()"
                class="px-5 py-2 rounded bg-vibe-surface border border-vibe-border text-vibe-text">取消</button>
        </div>
        <div id="api-result" class="mt-4 text-sm text-vibe-text"></div>
    </div>
</div>
<button onclick="openConvertModal()"
    class="bg-vibe-surface hover:bg-indigo-600/20 text-sm px-4 py-2 rounded-lg border border-vibe-border transition-colors flex items-center gap-2 shadow">
    <i class="ph ph-file-arrow-down text-lg"></i>
    <span>轉檔</span>
</button>
<!-- 轉檔視窗 -->
<div id="convert-modal" class="fixed inset-0 z-[111] bg-black/30 hidden flex items-center justify-center">
    <div class="bg-vibe-surface rounded-2xl shadow-lg border border-vibe-border p-8 flex flex-col gap-6 min-w-[420px]">
        <h2 class="text-xl font-semibold mb-2">多格式轉檔</h2>
        <div class="flex flex-col gap-3">
            <label class="flex items-center gap-2"><input type="radio" name="convert-type" value="word" checked
                    class="accent-indigo-500"> 匯出Word（docx）</label>
            <label class="flex items-center gap-2"><input type="radio" name="convert-type" value="png"
                    class="accent-green-500"> 匯出圖片（PNG）</label>
            <label class="flex items-center gap-2"><input type="radio" name="convert-type" value="jpg"
                    class="accent-amber-500"> 匯出圖片（JPG）</label>
        </div>
        <div class="flex gap-4 mt-4">
            <button id="convert-confirm" class="px-5 py-2 rounded bg-indigo-500 text-white font-medium">執行轉檔</button>
            <button onclick="closeConvertModal()"
                class="px-5 py-2 rounded bg-vibe-surface border border-vibe-border text-vibe-text">取消</button>
        </div>
    </div>
</div>
<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <style>
        .search-highlight {
            background: linear-gradient(90deg, #fef08a 60%, #f59e0b 100%);
            color: #222;
            border-radius: 4px;
            padding: 0 2px;
            box-shadow: 0 0 2px #f59e0b;
        }
    </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vibe PDF Editor</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts: Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">

    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <!-- PDF Libs -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <script>
        // --- API與協作功能 ---
        function openApiModal() {
            document.getElementById('api-modal').classList.remove('hidden');
            document.getElementById('api-modal').classList.add('flex');
        }
        function closeApiModal() {
            document.getElementById('api-modal').classList.add('hidden');
            document.getElementById('api-modal').classList.remove('flex');
            document.getElementById('api-result').textContent = '';
        }
        document.getElementById('api-confirm').onclick = async () => {
            let result = '';
            if (document.getElementById('api-export').checked) {
                // 匯出PDF至API（前端示意）
                result += 'PDF已匯出至API端點（僅示意）\n';
            }
            if (document.getElementById('api-collab').checked) {
                // 產生協作連結（前端示意）
                result += '協作連結：https://vibe-collab.example.com/xxxxxx\n';
            }
            if (document.getElementById('api-annotate').checked) {
                // 多人註解協作（前端示意）
                result += '多人註解協作已啟用（僅示意）\n';
            }
            document.getElementById('api-result').textContent = result;
            showToast('API/協作操作完成', 'success');
        };
        // --- 多格式轉檔（Word、圖片） ---
        function openConvertModal() {
            document.getElementById('convert-modal').classList.remove('hidden');
            document.getElementById('convert-modal').classList.add('flex');
        }
        function closeConvertModal() {
            document.getElementById('convert-modal').classList.add('hidden');
            document.getElementById('convert-modal').classList.remove('flex');
        }
        document.getElementById('convert-confirm').onclick = async () => {
            const type = document.querySelector('input[name="convert-type"]:checked').value;
            if (!state.pdfJsDoc) { showToast('請先載入PDF', 'warning'); return; }
            showLoading('轉檔中...');
            if (type === 'word') {
                // 匯出Word（docx）：僅將每頁文字匯出為docx（簡化示範）
                let docContent = '';
                for (let i = 1; i <= state.pdfJsDoc.numPages; i++) {
                    const page = await state.pdfJsDoc.getPage(i);
                    const textContent = await page.getTextContent();
                    docContent += `\n第${i}頁\n`;
                    docContent += textContent.items.map(item => item.str).join(' ');
                    docContent += '\n';
                }
                // 生成docx（前端僅示意，實際需用docx.js等）
                const blob = new Blob([docContent], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'vibe-export.docx';
                link.click();
                showToast('Word匯出完成', 'success');
            } else {
                // 匯出圖片（PNG/JPG）：每頁渲染為圖片
                for (let i = 1; i <= state.pdfJsDoc.numPages; i++) {
                    const page = await state.pdfJsDoc.getPage(i);
                    const viewport = page.getViewport({ scale: 2 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = Math.floor(viewport.width);
                    canvas.height = Math.floor(viewport.height);
                    await page.render({ canvasContext: context, viewport }).promise;
                    const dataUrl = canvas.toDataURL(type === 'png' ? 'image/png' : 'image/jpeg', 0.92);
                    const link = document.createElement('a');
                    link.href = dataUrl;
                    link.download = `vibe-export-page${i}.${type}`;
                    link.click();
                }
                showToast('圖片匯出完成', 'success');
            }
            hideLoading();
            closeConvertModal();
        };
        // --- PDF文字搜尋高亮 ---
        let searchResults = [];
        let searchTerm = '';
        document.getElementById('search-btn').onclick = async () => {
            const input = document.getElementById('search-input');
            searchTerm = input.value.trim();
            if (!searchTerm) {
                searchResults = [];
                document.getElementById('search-count').textContent = '';
                await renderPage(state.pageNum);
                return;
            }
            showLoading('搜尋中...');
            searchResults = [];
            for (let i = 1; i <= state.pdfJsDoc.numPages; i++) {
                const page = await state.pdfJsDoc.getPage(i);
                const textContent = await page.getTextContent();
                let matches = [];
                textContent.items.forEach((item, idx) => {
                    if (item.str && item.str.includes(searchTerm)) {
                        matches.push({
                            page: i,
                            index: idx,
                            text: item.str,
                            offset: item.str.indexOf(searchTerm)
                        });
                    }
                });
                if (matches.length) searchResults.push(...matches);
            }
            document.getElementById('search-count').textContent = `共 ${searchResults.length} 筆結果`;
            hideLoading();
            await renderPage(state.pageNum);
        };
        // 搜尋Enter快捷
        document.getElementById('search-input').addEventListener('keydown', e => {
            if (e.key === 'Enter') document.getElementById('search-btn').click();
        });
        // 高亮渲染
        const oldRenderPage = renderPage;
        async function renderPage(pageNum) {
            await oldRenderPage(pageNum);
            if (!searchTerm || !searchResults.length) return;
            const pageMatches = searchResults.filter(r => r.page === pageNum);
            if (!pageMatches.length) return;
            // 高亮文字
            const textLayer = document.getElementById('text-layer');
            if (!textLayer) return;
            pageMatches.forEach(match => {
                // 找到對應span
                const spans = textLayer.querySelectorAll('span');
                if (spans[match.index]) {
                    const span = spans[match.index];
                    const str = span.textContent;
                    const before = str.slice(0, match.offset);
                    const highlight = str.slice(match.offset, match.offset + searchTerm.length);
                    const after = str.slice(match.offset + searchTerm.length);
                    span.innerHTML = `${before}<span class='search-highlight'>${highlight}</span>${after}`;
                }
            });
        }
        // --- 多語系字串 ---
        const i18n = {
            'zh-TW': {
                title: 'Vibe PDF 編輯器',
                insertSig: '插入簽章欄位',
                export: '匯出 PDF',
                compress: '壓縮 PDF',
                prev: '上一頁',
                next: '下一頁',
                page: '頁',
                toastExport: '已匯出 PDF 檔案',
                toastInsertSig: '已插入簽章欄位',
                toastLoading: '處理中...',
            },
            'en': {
                title: 'Vibe PDF Editor',
                insertSig: 'Insert Signature Field',
                export: 'Export PDF',
                compress: 'Compress PDF',
                prev: 'Prev',
                next: 'Next',
                page: 'Page',
                toastExport: 'PDF exported',
                toastInsertSig: 'Signature field inserted',
                toastLoading: 'Processing...',
            }
        };
        let currentLang = 'zh-TW';
        function setLang(lang) {
            currentLang = lang;
            document.getElementById('main-title').textContent = i18n[lang].title;
            document.querySelector('button[onclick="insertSignatureField()"]')?.textContent = i18n[lang].insertSig;
            document.querySelector('button[onclick="downloadPdf()"]')?.textContent = i18n[lang].export;
            document.querySelector('button[onclick="openCompressModal()"]')?.textContent = i18n[lang].compress;
            document.getElementById('prev-page').title = i18n[lang].prev;
            document.getElementById('next-page').title = i18n[lang].next;
        }
        window.onload = () => setLang(currentLang);
        // --- Toast ---
        function showToast(msg, type = 'info', duration = 2200, icon = null) {
            // 多語系自動翻譯
            if (msg === '已匯出 PDF 檔案') { msg = i18n[currentLang].toastExport; }
            else if (msg === '已插入簽章欄位') { msg = i18n[currentLang].toastInsertSig; }
            else if (msg === '處理中...') { msg = i18n[currentLang].toastLoading; }
            const overlay = document.getElementById('ui-overlays');
            const toast = document.createElement('div');
            toast.className = `pointer-events-auto fixed left-1/2 top-8 -translate-x-1/2 z-[101] px-6 py-3 rounded-xl shadow-lg font-medium text-base flex items-center gap-2 transition-all duration-300 opacity-0 ${type === 'error' ? 'bg-red-600 text-white' : type === 'success' ? 'bg-green-600 text-white' : type === 'warning' ? 'bg-yellow-500 text-black' : 'bg-vibe-surface text-vibe-text border border-vibe-border'}`;
            let iconHtml = icon ? `<i class="ph ${icon}"></i>` : `<i class="ph ${type === 'error' ? 'ph-warning' : type === 'success' ? 'ph-check-circle' : type === 'warning' ? 'ph-warning-circle' : 'ph-info'}"></i>`;
            toast.innerHTML = `${iconHtml} ${msg}`;
            overlay.appendChild(toast);
            setTimeout(() => { toast.style.opacity = 1; }, 10);
            setTimeout(() => { toast.style.opacity = 0; setTimeout(() => toast.remove(), 300); }, duration);
        }

        // --- Loading Spinner ---
        function showLoading(msg = '處理中...') {
            const overlay = document.getElementById('ui-overlays');
            let spinner = document.getElementById('global-spinner');
            if (!spinner) {
                spinner = document.createElement('div');
                spinner.id = 'global-spinner';
                spinner.className = 'pointer-events-auto fixed inset-0 flex items-center justify-center z-[102] bg-black/30';
                spinner.innerHTML = `<div class="flex flex-col items-center gap-4 p-8 bg-vibe-surface/90 rounded-2xl shadow-lg border border-vibe-border"><svg class="animate-spin h-10 w-10 text-indigo-500" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"></path></svg><span class="text-base font-medium text-vibe-text">${msg}</span></div>`;
                overlay.appendChild(spinner);
            }
        }
        function hideLoading() {
            const spinner = document.getElementById('global-spinner');
            if (spinner) spinner.remove();
        }

        // --- 主題切換 ---
        const themeToggle = document.getElementById('theme-toggle');
        let darkMode = true;
        let themeColor = 'indigo';
        function setTheme(dark) {
            darkMode = dark;
            document.body.classList.toggle('dark', dark);
            if (themeToggle) {
                themeToggle.innerHTML = `<i class="ph ${dark ? 'ph-moon' : 'ph-sun'}"></i>`;
                themeToggle.title = dark ? '切換為亮色主題' : '切換為深色主題';
            }
            setThemeColor(themeColor);
        }
        function setThemeColor(color) {
            themeColor = color;
            // Tailwind主題色切換
            const root = document.documentElement;
            let accent, bg;
            if (color === 'indigo') {
                accent = '#6366F1'; bg = '#0F1117';
            } else if (color === 'emerald') {
                accent = '#10B981'; bg = '#0F1117';
            } else if (color === 'rose') {
                accent = '#F43F5E'; bg = '#1E212B';
            } else if (color === 'amber') {
                accent = '#F59E0B'; bg = '#1E212B';
            }
            root.style.setProperty('--tw-bg-opacity', '1');
            document.body.style.backgroundColor = bg;
            // 主要accent色
            document.querySelectorAll('.bg-indigo-600').forEach(e => e.style.backgroundColor = accent);
            document.querySelectorAll('.border-indigo-500').forEach(e => e.style.borderColor = accent);
            document.querySelectorAll('.text-indigo-400').forEach(e => e.style.color = accent);
            document.querySelectorAll('.hover\:bg-indigo-600\/20').forEach(e => e.style.backgroundColor = accent + '33');
        }
        if (themeToggle) {
            themeToggle.onclick = () => setTheme(!darkMode);
        }
        setTheme(true);
        // 設定 PDF.js Worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        vibe: {
                            bg: '#0F1117',
                            surface: '#1E212B',
                            accent: '#6366F1',
                            text: '#E2E8F0',
                            border: '#2D3748'
                        }
                    }
                }
            }
        }
    </script>

    <style>
        body {
            background-color: #0F1117;
            color: #E2E8F0;
            overflow: hidden;
        }

        /* 自定義捲軸 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1E212B;
        }

        ::-webkit-scrollbar-thumb {
            background: #4A5568;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #718096;
        }

        .canvas-container {
            box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        .tool-btn {
            @apply p-3 rounded-2xl text-gray-300 hover:text-white hover:bg-vibe-surface transition-all duration-200 flex flex-col items-center gap-1.5 text-sm;
        }

        .tool-btn.active {
            @apply bg-indigo-600/20 text-indigo-400 border border-indigo-500/30;
        }

        /* 拖曳中的文字 */
        .draggable-text {
            position: absolute;
            cursor: move;
            border: 1px dashed transparent;
            padding: 2px 6px;
            background: rgba(0, 0, 0, 0.1);
            color: black;
            /* 預設為黑色，因為 PDF 背景通常是白色 */
            font-family: Helvetica, sans-serif;
            font-size: 16px;
            min-width: 50px;
            outline: none;
            border-radius: 4px;
        }

        .draggable-text:focus {
            border-color: #6366F1;
            background: rgba(99, 102, 241, 0.1);
        }

        /* 繪圖層 */
        #drawing-layer {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: none;
            /* 預設不攔截事件，除非在繪圖模式 */
        }

        #drawing-layer.drawing-mode {
            pointer-events: auto;
            cursor: crosshair;
        }

        .page-indicator {
            font-feature-settings: "tnum";
            font-variant-numeric: tabular-nums;
        }

        .page-item {
            border: 1px solid transparent;
        }

        .page-item.active {
            border-color: #6366F1;
            box-shadow: 0 0 0 1px rgba(99, 102, 241, 0.35);
        }

        .page-item.drag-over {
            border-color: #818CF8;
            background: rgba(99, 102, 241, 0.08);
        }
    </style>
</head>

<body class="flex flex-col h-screen font-sans bg-vibe-bg text-vibe-text">
    <!-- Toast/Loading/主題切換區 -->
    <div id="ui-overlays" class="fixed inset-0 pointer-events-none z-[100]"></div>
    <!-- 搜尋工具欄 -->
    <div class="fixed top-20 left-1/2 -translate-x-1/2 z-[101] flex items-center gap-2 bg-vibe-surface border border-vibe-border rounded-xl shadow-lg px-4 py-2"
        style="min-width:320px">
        <input id="search-input" type="text" placeholder="搜尋PDF文字..."
            class="px-3 py-2 rounded border border-vibe-border bg-white text-black dark:bg-vibe-surface dark:text-vibe-text"
            style="min-width:220px">
        <button id="search-btn" class="px-3 py-2 rounded bg-indigo-500 text-white font-medium"><i
                class="ph ph-magnifying-glass"></i> 搜尋</button>
        <span id="search-count" class="text-sm text-gray-400"></span>
    </div>

    <!-- Header -->
    <header
        class="h-16 border-b border-vibe-border bg-vibe-bg/95 backdrop-blur flex items-center justify-between px-8 shadow z-50">
        <div class="flex items-center gap-4">
            <div
                class="w-10 h-10 rounded-xl bg-gradient-to-br from-indigo-500 to-purple-600 flex items-center justify-center text-white font-bold text-xl shadow-lg">
                V</div>
            <h1 class="font-semibold text-2xl tracking-tight" id="main-title">Vibe PDF 編輯器</h1>
        </div>
        <div class="flex items-center gap-3">
            <button onclick="undoAction()"
                class="px-2 py-1 rounded border border-vibe-border bg-vibe-surface text-sm mr-1" title="Undo"><i
                    class="ph ph-arrow-counter-clockwise"></i></button>
            <button onclick="redoAction()"
                class="px-2 py-1 rounded border border-vibe-border bg-vibe-surface text-sm mr-1" title="Redo"><i
                    class="ph ph-arrow-clockwise"></i></button>
            <select id="theme-select" class="px-2 py-1 rounded border border-vibe-border bg-vibe-surface text-sm mr-2"
                onchange="setThemeColor(this.value)">
                <option value="indigo">主題：藍紫</option>
                <option value="emerald">主題：綠色</option>
                <option value="rose">主題：玫瑰</option>
                <option value="amber">主題：琥珀</option>
            </select>
            <select id="lang-select" class="px-2 py-1 rounded border border-vibe-border bg-vibe-surface text-sm mr-2"
                onchange="setLang(this.value)">
                <option value="zh-TW">繁體中文</option>
                <option value="en">English</option>
            </select>
            <label class="flex items-center gap-2 text-sm">
                <input type="checkbox" id="remove-nonstandard" class="accent-indigo-600">
                <span>匯出時移除非標準物件</span>
            </label>
            <label
                class="cursor-pointer bg-vibe-surface hover:bg-indigo-600/20 text-sm px-4 py-2 rounded-lg border border-vibe-border transition-colors flex items-center gap-2 shadow">
                <i class="ph ph-upload-simple text-lg"></i>
                <span>開啟 PDF</span>
                <input type="file" id="file-upload" accept="application/pdf" class="hidden">
            </label>
            <button onclick="openCompressModal()"
                class="bg-vibe-surface hover:bg-indigo-600/20 text-sm px-4 py-2 rounded-lg border border-vibe-border transition-colors flex items-center gap-2 shadow">
                <i class="ph ph-arrows-in text-lg"></i>
                <span>壓縮 PDF</span>
            </button>
            <button onclick="openBatchModal()"
                class="bg-vibe-surface hover:bg-indigo-600/20 text-sm px-4 py-2 rounded-lg border border-vibe-border transition-colors flex items-center gap-2 shadow">
                <i class="ph ph-list-check text-lg"></i>
                <span>批次處理</span>
            </button>
            <!-- 批次處理視窗 -->
            <div id="batch-modal" class="fixed inset-0 z-[110] bg-black/30 hidden flex items-center justify-center">
                <div
                    class="bg-vibe-surface rounded-2xl shadow-lg border border-vibe-border p-8 flex flex-col gap-6 min-w-[420px]">
                    <h2 class="text-xl font-semibold mb-2">批次處理</h2>
                    <div class="flex flex-col gap-3">
                        <label class="flex items-center gap-2"><input type="checkbox" id="batch-delete"
                                class="accent-red-500"> 批量刪除選取頁</label>
                        <label class="flex items-center gap-2"><input type="checkbox" id="batch-merge"
                                class="accent-indigo-500"> 批量合併選取頁</label>
                        <label class="flex items-center gap-2"><input type="checkbox" id="batch-export"
                                class="accent-green-500"> 批量匯出選取頁</label>
                        <label class="flex items-center gap-2"><input type="checkbox" id="batch-compress"
                                class="accent-amber-500"> 批量壓縮選取頁</label>
                    </div>
                    <div class="flex gap-4 mt-4">
                        <button id="batch-confirm"
                            class="px-5 py-2 rounded bg-indigo-500 text-white font-medium">執行批次</button>
                        <button onclick="closeBatchModal()"
                            class="px-5 py-2 rounded bg-vibe-surface border border-vibe-border text-vibe-text">取消</button>
                    </div>
                </div>
            </div>
            // --- 批次處理與自動化 ---
            function openBatchModal() {
            document.getElementById('batch-modal').classList.remove('hidden');
            document.getElementById('batch-modal').classList.add('flex');
            }
            function closeBatchModal() {
            document.getElementById('batch-modal').classList.add('hidden');
            document.getElementById('batch-modal').classList.remove('flex');
            }
            document.getElementById('batch-confirm').onclick = async () => {
            const selected = Array.from(els.pageList.querySelectorAll('.page-item.selected'));
            if (!selected.length) { showToast('請先選取頁面', 'warning'); return; }
            const indices = selected.map(item => parseInt(item.dataset.index));
            if (document.getElementById('batch-delete').checked) {
            for (let idx of indices.reverse()) await deletePageAt(idx);
            showToast('批量刪除完成', 'success');
            }
            if (document.getElementById('batch-merge').checked) {
            // 合併內容：將後面頁的內容繪製到第一頁（簡化為刪除後面頁）
            for (let i = 1; i < indices.length; i++) { state.pdfDoc.removePage(indices[i]); } await
                rebuildPdfJsDoc(indices[0] + 1); await buildPageList(); showToast('批量合併完成', 'success' ); } if
                (document.getElementById('batch-export').checked) { // 匯出選取頁（簡化為單一PDF） const tempDoc=await
                PDFLib.PDFDocument.create(); for (let idx of indices) { const page=await tempDoc.copyPages(state.pdfDoc,
                [idx]); tempDoc.addPage(page[0]); } const pdfBytes=await tempDoc.save(); const blob=new Blob([pdfBytes],
                { type: 'application/pdf' }); const link=document.createElement('a');
                link.href=URL.createObjectURL(blob); link.download='vibe-batch-export.pdf' ; link.click();
                showToast('批量匯出完成', 'success' ); } if (document.getElementById('batch-compress').checked) { //
                壓縮選取頁（簡化為低品質匯出） const tempDoc=await PDFLib.PDFDocument.create(); for (let idx of indices) { const
                page=await tempDoc.copyPages(state.pdfDoc, [idx]); tempDoc.addPage(page[0]); } const pdfBytes=await
                tempDoc.save({ useObjectStreams: true }); const blob=new Blob([pdfBytes], { type: 'application/pdf' });
                const link=document.createElement('a'); link.href=URL.createObjectURL(blob);
                link.download='vibe-batch-compress.pdf' ; link.click(); showToast('批量壓縮完成', 'success' ); }
                closeBatchModal(); }; <button onclick="downloadPdf()"
                class="bg-indigo-600 hover:bg-indigo-500 text-white text-sm px-4 py-2 rounded-lg shadow-lg shadow-indigo-500/20 transition-all flex items-center gap-2 font-medium">
                <i class="ph ph-download-simple text-lg"></i>
                <span>匯出檔案</span>
                </button>
                <button id="theme-toggle"
                    class="ml-2 p-2 rounded-full border border-vibe-border bg-vibe-surface hover:bg-indigo-600/20 transition-colors text-lg"
                    title="切換主題">
                    <i class="ph ph-moon"></i>
                </button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        <!-- 左側工具欄 -->
        <aside class="w-24 bg-vibe-bg border-r border-vibe-border flex flex-col items-center py-8 gap-4 z-40">
            <button class="tool-btn active" id="tool-cursor" onclick="setTool('cursor')" title="選取">
                <i class="ph ph-cursor text-3xl"></i>
                <span class="mt-1">選取</span>
            </button>
            <button class="tool-btn" id="tool-text" onclick="setTool('text')" title="文字">
                <i class="ph ph-text-t text-3xl"></i>
                <span class="mt-1">文字</span>
            </button>
            <button class="tool-btn" id="tool-draw" onclick="setTool('draw')" title="繪圖">
                <i class="ph ph-pencil-simple text-3xl"></i>
                <span class="mt-1">繪圖</span>
            </button>
            <div class="w-10 h-[1px] bg-vibe-border my-3"></div>
            <button class="tool-btn" onclick="rotatePage()" title="旋轉頁面">
                <i class="ph ph-arrows-clockwise text-3xl"></i>
                <span class="mt-1">旋轉</span>
            </button>
            <button class="tool-btn hover:text-red-400" onclick="deletePage()" title="刪除頁面">
                <i class="ph ph-trash text-3xl"></i>
                <span class="mt-1">刪除</span>
            </button>
        </aside>

        <!-- 主要工作區 -->
        <main class="flex-1 bg-[#10121a] relative overflow-auto flex justify-center items-center p-8" id="main-scroll">
            <!-- 未加載狀態 -->
            <div id="empty-state"
                class="absolute inset-0 flex flex-col items-center justify-center text-gray-500 border-4 border-dashed border-indigo-500/30 rounded-2xl bg-vibe-surface/60 pointer-events-none select-none">
                <i class="ph ph-files text-7xl mb-4 opacity-60"></i>
                <p class="text-xl font-medium">拖放 PDF 到這裡<br>或點擊上方「開啟 PDF」</p>
            </div>
            <!-- PDF 渲染容器 -->
            <div id="pdf-wrapper" class="relative hidden flex flex-col items-center justify-center">
                <canvas id="pdf-render"
                    class="block rounded-2xl shadow-2xl border-2 border-vibe-border bg-white"></canvas>
                <!-- 繪圖畫布 (覆蓋在 PDF 上) -->
                <canvas id="drawing-layer"></canvas>
                <!-- 文字輸入層 -->
                <div id="text-layer" class="absolute inset-0 z-20 pointer-events-none"></div>
            </div>
        </main>

        <!-- 右側頁面目錄 -->
        <aside class="w-80 bg-vibe-bg border-l border-vibe-border flex flex-col">
            <div class="p-5 border-b border-vibe-border bg-vibe-surface/80">
                <div class="flex items-center justify-between">
                    <h2 class="text-lg font-semibold text-gray-200">頁面目錄</h2>
                    <div class="flex items-center gap-2">
                        <button onclick="insertSignatureField()"
                            class="text-sm px-3 py-1.5 rounded-md bg-vibe-surface border border-vibe-border hover:bg-purple-600/20 transition-colors">插入簽章欄位</button>
                        <button onclick="insertBlankPage()"
                            class="text-sm px-3 py-1.5 rounded-md bg-indigo-600 hover:bg-indigo-500 text-white border border-indigo-500 shadow transition-colors">新增頁</button>
                        <button onclick="triggerImageInsert()"
                            class="text-sm px-3 py-1.5 rounded-md bg-vibe-surface border border-vibe-border hover:bg-indigo-600/20 transition-colors">插入圖片</button>
                        <button onclick="mergeSelectedPages()"
                            class="text-sm px-3 py-1.5 rounded-md bg-vibe-surface border border-vibe-border hover:bg-green-600/20 transition-colors">合併</button>
                        <button onclick="splitPage()"
                            class="text-sm px-3 py-1.5 rounded-md bg-vibe-surface border border-vibe-border hover:bg-yellow-600/20 transition-colors">分割</button>
                        <button onclick="duplicatePage()"
                            class="text-sm px-3 py-1.5 rounded-md bg-vibe-surface border border-vibe-border hover:bg-blue-600/20 transition-colors">複製</button>
                    </div>
                </div>
                <p class="text-sm text-gray-400 mt-2">拖曳可重新排序</p>
            </div>
            <input type="file" id="image-insert" accept="image/png,image/jpeg" class="hidden" />
            <div id="page-list" class="flex-1 overflow-auto p-5 space-y-4"></div>
        </aside>
    </div>

    <!-- 底部頁面控制 -->
    <footer
        class="h-16 border-t border-vibe-border bg-vibe-bg flex items-center justify-center gap-8 z-50 shadow-inner">
        <button onclick="changePage(-1)"
            class="p-3 hover:bg-indigo-600/20 rounded-full transition-colors disabled:opacity-30" id="prev-page">
            <i class="ph ph-caret-left text-2xl"></i>
        </button>
        <span
            class="text-base font-semibold bg-vibe-surface px-6 py-2 rounded-full border border-vibe-border page-indicator shadow">
            <span id="page-num">0</span> / <span id="page-count">0</span>
        </span>
        <button onclick="changePage(1)"
            class="p-3 hover:bg-indigo-600/20 rounded-full transition-colors disabled:opacity-30" id="next-page">
            <i class="ph ph-caret-right text-2xl"></i>
        </button>
    </footer>

    <!-- 壓縮設定視窗 -->
    <div id="compress-modal"
        class="fixed inset-0 bg-black/60 backdrop-blur-sm hidden items-center justify-center z-[60]">
        <div class="w-[420px] bg-vibe-surface border border-vibe-border rounded-2xl p-6 shadow-2xl">
            <div class="flex items-center justify-between">
                <h3 class="text-lg font-semibold">PDF 壓縮設定</h3>
                <button onclick="closeCompressModal()" class="text-gray-400 hover:text-white">
                    <i class="ph ph-x text-xl"></i>
                </button>
            </div>

            <p class="text-sm text-gray-400 mt-3">
                會將頁面光柵化以降低檔案大小，文字會變成圖片。
            </p>

            <div class="mt-5 space-y-4">
                <div>
                    <label class="text-sm text-gray-300">壓縮模式</label>
                    <select id="compress-mode"
                        class="mt-2 w-full bg-vibe-bg border border-vibe-border rounded-lg px-3 py-2 text-sm">
                        <option value="lossless">無損 / 結構壓縮（保留文字向量）</option>
                        <option value="raster">高壓縮 / 光柵化（畫質取決於參數）</option>
                    </select>
                </div>

                <div>
                    <label class="text-sm text-gray-300">解析度比例</label>
                    <div class="flex items-center gap-3 mt-2">
                        <input id="compress-scale" type="range" min="0.5" max="1" step="0.05" value="0.8"
                            class="w-full">
                        <span id="compress-scale-value" class="text-sm text-gray-300 w-12 text-right">0.80</span>
                    </div>
                </div>

                <div>
                    <label class="text-sm text-gray-300">JPEG 品質</label>
                    <div class="flex items-center gap-3 mt-2">
                        <input id="compress-quality" type="range" min="0.5" max="0.95" step="0.05" value="0.8"
                            class="w-full">
                        <span id="compress-quality-value" class="text-sm text-gray-300 w-12 text-right">0.80</span>
                    </div>
                </div>
            </div>

            <div class="mt-6 flex items-center justify-end gap-3">
                <button onclick="closeCompressModal()"
                    class="px-4 py-2 rounded-lg border border-vibe-border text-sm hover:bg-gray-700 transition-colors">
                    取消
                </button>
                <button id="compress-action" onclick="compressPdf()"
                    class="px-4 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-500 text-white text-sm font-medium">
                    開始壓縮
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- 狀態管理 ---
        const state = {
            pdfDoc: null,           // PDFLib 文檔 (用於編輯)
            pdfBytes: null,         // 原始二進位資料
            pdfJsDoc: null,         // PDF.js 文檔 (用於顯示)
            pageNum: 1,
            scale: 1.5,             // 渲染縮放比例 (高解析度)
            tool: 'cursor',         // 當前工具: cursor, text, draw
            pagesDetails: [],       // 記錄每頁的旋轉角度等資訊
            annotations: [],        // [ [ { x, y, content } ] ]
            drawings: [],           // [ imageDataUrl | null ]
            isDrawing: false,
            lastX: 0,
            lastY: 0,
            history: [],            // 操作歷史堆疊
            historyIndex: -1        // 當前歷史指標
        };

        function pushHistory() {
            // 深拷貝主要狀態
            const snapshot = {
                pageNum: state.pageNum,
                annotations: JSON.parse(JSON.stringify(state.annotations)),
                drawings: JSON.parse(JSON.stringify(state.drawings)),
                pagesDetails: JSON.parse(JSON.stringify(state.pagesDetails)),
                formFields: state.formFields ? JSON.parse(JSON.stringify(state.formFields)) : null
            };
            // 若undo後有新操作，移除redo分支
            if (state.historyIndex < state.history.length - 1) {
                state.history = state.history.slice(0, state.historyIndex + 1);
            }
            state.history.push(snapshot);
            state.historyIndex = state.history.length - 1;
        }

        function undoAction() {
            if (state.historyIndex <= 0) return showToast('無可還原操作', 'info');
            state.historyIndex--;
            applyHistory(state.history[state.historyIndex]);
            showToast('已還原操作', 'success');
        }
        function redoAction() {
            if (state.historyIndex >= state.history.length - 1) return showToast('無可重做操作', 'info');
            state.historyIndex++;
            applyHistory(state.history[state.historyIndex]);
            showToast('已重做操作', 'success');
        }
        function applyHistory(snapshot) {
            state.pageNum = snapshot.pageNum;
            state.annotations = JSON.parse(JSON.stringify(snapshot.annotations));
            state.drawings = JSON.parse(JSON.stringify(snapshot.drawings));
            state.pagesDetails = JSON.parse(JSON.stringify(snapshot.pagesDetails));
            if (snapshot.formFields) state.formFields = JSON.parse(JSON.stringify(snapshot.formFields));
            renderPage(state.pageNum);
            buildPageList();
        }

        // --- DOM 元素 ---
        const els = {
            fileInput: document.getElementById('file-upload'),
            pdfWrapper: document.getElementById('pdf-wrapper'),
            pdfCanvas: document.getElementById('pdf-render'),
            drawCanvas: document.getElementById('drawing-layer'),
            textLayer: document.getElementById('text-layer'),
            emptyState: document.getElementById('empty-state'),
            pageNum: document.getElementById('page-num'),
            pageCount: document.getElementById('page-count'),
            toolBtns: document.querySelectorAll('.tool-btn'),
            pageList: document.getElementById('page-list'),
            imageInsert: document.getElementById('image-insert'),
            compressModal: document.getElementById('compress-modal'),
            compressMode: document.getElementById('compress-mode'),
            compressScale: document.getElementById('compress-scale'),
            compressQuality: document.getElementById('compress-quality'),
            compressScaleValue: document.getElementById('compress-scale-value'),
            compressQualityValue: document.getElementById('compress-quality-value'),
            compressAction: document.getElementById('compress-action')
        };

        const ctx = els.pdfCanvas.getContext('2d');
        const drawCtx = els.drawCanvas.getContext('2d');

        // --- 初始化 ---
        els.fileInput.addEventListener('change', handleFileSelect);
        els.compressScale.addEventListener('input', () => {
            els.compressScaleValue.textContent = Number(els.compressScale.value).toFixed(2);
        });
        els.compressQuality.addEventListener('input', () => {
            els.compressQualityValue.textContent = Number(els.compressQuality.value).toFixed(2);
        });
        els.compressMode.addEventListener('change', () => {
            const isRaster = els.compressMode.value === 'raster';
            els.compressScale.disabled = !isRaster;
            els.compressQuality.disabled = !isRaster;
            els.compressScaleValue.style.opacity = isRaster ? '1' : '0.5';
            els.compressQualityValue.style.opacity = isRaster ? '1' : '0.5';
        });

        const mainScroll = document.getElementById('main-scroll');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            mainScroll.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
            document.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        mainScroll.addEventListener('dragover', () => {
            mainScroll.classList.add('ring-2', 'ring-indigo-500/60');
        });

        mainScroll.addEventListener('dragleave', () => {
            mainScroll.classList.remove('ring-2', 'ring-indigo-500/60');
        });

        mainScroll.addEventListener('drop', async (e) => {
            mainScroll.classList.remove('ring-2', 'ring-indigo-500/60');
            const file = e.dataTransfer.files && e.dataTransfer.files[0];
            if (!file || file.type !== 'application/pdf') {
                showToast('請拖放 PDF 檔案', 'error');
                return;
            }
            await handleFileBuffer(file);
        });

        document.addEventListener('drop', async (e) => {
            const file = e.dataTransfer.files && e.dataTransfer.files[0];
            if (!file) return;
            if (file.type !== 'application/pdf') {
                showToast('請拖放 PDF 檔案', 'error');
                return;
            }
            await handleFileBuffer(file);
        });

        // --- 工具切換邏輯 ---
        function setTool(toolName) {
            state.tool = toolName;

            // UI 更新
            els.toolBtns.forEach(btn => {
                btn.classList.remove('active');
                if (btn.id === `tool-${toolName}`) btn.classList.add('active');
            });

            // 畫布互動模式設定
            if (toolName === 'draw') {
                els.drawCanvas.classList.add('drawing-mode');
                els.textLayer.style.pointerEvents = 'none'; // 繪圖時文字不可點
            } else if (toolName === 'text') {
                els.drawCanvas.classList.remove('drawing-mode');
                els.textLayer.style.pointerEvents = 'auto'; // 允許點擊文字層(新增)
            } else {
                els.drawCanvas.classList.remove('drawing-mode');
                els.textLayer.style.pointerEvents = 'auto'; // 允許拖曳文字
            }
        }

        // --- 檔案處理 ---
        async function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            await handleFileBuffer(file);
        }

        async function handleFileBuffer(file) {
            const arrayBuffer = await file.arrayBuffer();
            state.pdfBytes = arrayBuffer;

            // PDF安全合規檢查
            const pdfjsDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
            let unsafe = false, unsafeMsg = [];
            for (let i = 1; i <= pdfjsDoc.numPages; i++) {
                const page = await pdfjsDoc.getPage(i);
                const annos = await page.getAnnotations();
                for (const anno of annos) {
                    if (anno.subtype === 'Widget' && anno.hasOwnProperty('xfa')) {
                        unsafe = true;
                        unsafeMsg.push('偵測到 XFA 動態表單 (非標準)');
                    }
                    if (anno.subtype === 'RichMedia') {
                        unsafe = true;
                        unsafeMsg.push('偵測到嵌入式多媒體 (非標準)');
                    }
                    if (anno.subtype === 'JavaScript') {
                        unsafe = true;
                        unsafeMsg.push('偵測到嵌入式腳本 (非標準)');
                    }
                }
            }
            if (unsafe) {
                showToast('PDF 含非標準內容：' + unsafeMsg.join('、'), 'warning', 5000, 'ph-shield-warning');
            }

            // 載入 PDF-Lib (用於後續編輯)
            state.pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);

            // 載入 PDF.js (用於渲染)
            state.pdfJsDoc = pdfjsDoc;

            // 初始化狀態
            state.pageNum = 1;
            state.pagesDetails = new Array(state.pdfJsDoc.numPages).fill({ rotation: 0 });
            state.annotations = Array.from({ length: state.pdfJsDoc.numPages }, () => []);
            state.drawings = Array.from({ length: state.pdfJsDoc.numPages }, () => null);

            // 表單欄位偵測
            state.formFields = await detectPdfFormFields(state.pdfJsDoc);
            renderPdfFormFields(state.formFields);

            els.pageCount.textContent = state.pdfJsDoc.numPages;
            els.emptyState.classList.add('hidden');
            els.pdfWrapper.classList.remove('hidden');

            renderPage(state.pageNum);
            buildPageList();
        }

        // PDF 表單欄位偵測
        async function detectPdfFormFields(pdfJsDoc) {
            const fields = [];
            for (let i = 1; i <= pdfJsDoc.numPages; i++) {
                const page = await pdfJsDoc.getPage(i);
                const annotations = await page.getAnnotations();
                for (const anno of annotations) {
                    if (anno.subtype === 'Widget' && anno.fieldName) {
                        fields.push({
                            page: i,
                            name: anno.fieldName,
                            type: anno.fieldType,
                            rect: anno.rect,
                            value: anno.fieldValue || '',
                        });
                    }
                }
            }
            return fields;
        }

        // PDF 表單欄位 UI
        function renderPdfFormFields(fields) {
            // 移除舊欄位
            document.querySelectorAll('.pdf-form-field').forEach(e => e.remove());
            for (const field of fields) {
                if (field.page !== state.pageNum) continue;
                let input;
                if (field.type === 'Sig') {
                    input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'pdf-form-field absolute z-30 bg-white text-purple-700 rounded border border-vibe-border px-2 py-1 text-sm font-bold';
                    input.placeholder = '簽章欄位';
                    input.value = field.value;
                    input.oninput = () => field.value = input.value;
                } else {
                    input = document.createElement('input');
                    input.className = 'pdf-form-field absolute z-30 bg-white text-black rounded border border-vibe-border px-2 py-1 text-sm';
                    input.value = field.value;
                    input.placeholder = field.name;
                    input.oninput = () => field.value = input.value;
                }
                input.style.left = `${field.rect[0]}px`;
                input.style.top = `${field.rect[1]}px`;
                input.style.width = `${field.rect[2] - field.rect[0]}px`;
                input.style.height = `${field.rect[3] - field.rect[1]}px`;
                els.pdfWrapper.appendChild(input);
            }
        }

        // 插入簽章欄位
        async function insertSignatureField() {
            if (!state.pdfDoc) return;
            const idx = getCurrentPageIndex();
            const page = state.pdfDoc.getPages()[idx];
            const { width, height } = page.getSize();
            // 插入標準簽章欄位（簡化為表單欄位 type: Sig）
            if (!state.formFields) state.formFields = [];
            state.formFields.push({
                page: idx + 1,
                name: 'Signature' + Date.now(),
                type: 'Sig',
                rect: [width * 0.6, height * 0.85, width * 0.9, height * 0.95],
                value: '',
            });
            renderPdfFormFields(state.formFields);
            showToast(i18n[currentLang].toastInsertSig, 'success');
        }

        // 切換頁面時同步表單欄位
        const origRenderPage = renderPage;
        renderPage = async function (num) {
            await origRenderPage(num);
            if (state.formFields) renderPdfFormFields(state.formFields);
        }

        // --- 匯出功能 ---
        async function downloadPdf() {
            if (!state.pdfDoc) return;
            showLoading('PDF 產生中...');
            // 匯出前安全合規報告
            let unsafe = false, unsafeMsg = [];
            const pdfjsDoc = await pdfjsLib.getDocument(await state.pdfDoc.save()).promise;
            let removeNonstandard = document.getElementById('remove-nonstandard')?.checked;
            for (let i = 1; i <= pdfjsDoc.numPages; i++) {
                const page = await pdfjsDoc.getPage(i);
                const annos = await page.getAnnotations();
                for (const anno of annos) {
                    if (anno.subtype === 'Widget' && anno.hasOwnProperty('xfa')) {
                        unsafe = true;
                        unsafeMsg.push('XFA 動態表單');
                        if (removeNonstandard) {
                            // 移除XFA（僅提示，實際移除需後端或PDF-Lib支援）
                        }
                    }
                    if (anno.subtype === 'RichMedia') {
                        unsafe = true;
                        unsafeMsg.push('嵌入式多媒體');
                        if (removeNonstandard) {
                            // 移除RichMedia（僅提示）
                        }
                    }
                    if (anno.subtype === 'JavaScript') {
                        unsafe = true;
                        unsafeMsg.push('嵌入式腳本');
                        if (removeNonstandard) {
                            // 移除JavaScript（僅提示）
                        }
                    }
                }
            }
            if (unsafe) {
                showToast('匯出前安全合規警告：' + unsafeMsg.join('、') + (removeNonstandard ? '（已選擇移除）' : ''), removeNonstandard ? 'success' : 'warning', 5000, 'ph-shield-warning');
            } else {
                showToast('匯出前安全合規檢查：通過', 'success', 2000);
            }
            // 1. 將所有的標註寫入 PDF
            const pages = state.pdfDoc.getPages();
            for (let i = 0; i < pages.length; i++) {
                const pageNum = i + 1;
                const page = pages[i];
                const { width, height } = page.getSize();
                // 處理文字
                const annos = state.annotations[i] || [];
                for (const anno of annos) {
                    const pdfX = anno.x / state.scale;
                    const pdfY = height - (anno.y / state.scale) - 12;
                    page.drawText(anno.content, {
                        x: pdfX,
                        y: pdfY,
                        size: 16 / state.scale * 1.5,
                        color: PDFLib.rgb(0, 0, 0),
                    });
                }
                // 處理繪圖
                const drawingDataUrl = state.drawings[i];
                if (drawingDataUrl) {
                    const pngImage = await state.pdfDoc.embedPng(drawingDataUrl);
                    page.drawImage(pngImage, {
                        x: 0,
                        y: 0,
                        width: width,
                        height: height,
                    });
                }
            }
            // 表單欄位填寫內容寫入 PDF
            if (state.formFields && state.formFields.length) {
                for (const field of state.formFields) {
                    const pdfField = state.pdfDoc.getForm().getTextField(field.name);
                    if (pdfField) pdfField.setText(field.value);
                }
            }
            const pdfBytes = await state.pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'vibe-edited.pdf';
            link.click();
            hideLoading();
            showToast('已匯出 PDF 檔案', 'success');
        }

        // --- 文字標註工具選單 ---
        const annotationToolbar = document.createElement('div');
        annotationToolbar.id = 'annotation-toolbar';
        annotationToolbar.className = 'fixed top-20 left-1/2 -translate-x-1/2 z-[90] bg-vibe-surface border border-vibe-border rounded-xl shadow-lg px-4 py-2 flex items-center gap-3';
        annotationToolbar.innerHTML = `
            <label>顏色 <input type="color" id="anno-color" value="#222222" class="w-8 h-8 border rounded"></label>
            <label>字型 <select id="anno-font" class="border rounded px-2 py-1">
                <option value="Inter">Inter</option>
                <option value="Arial">Arial</option>
                <option value="Helvetica">Helvetica</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Courier New">Courier New</option>
            </select></label>
            <label>大小 <input type="number" id="anno-size" min="10" max="48" value="16" class="w-16 border rounded px-2 py-1"></label>
        `;
        document.body.appendChild(annotationToolbar);
        let annoColor = '#222222', annoFont = 'Inter', annoSize = 16;
        annotationToolbar.querySelector('#anno-color').oninput = e => annoColor = e.target.value;
        annotationToolbar.querySelector('#anno-font').oninput = e => annoFont = e.target.value;
        annotationToolbar.querySelector('#anno-size').oninput = e => annoSize = parseInt(e.target.value);

        // 點擊 Text Layer 新增文字
        els.textLayer.addEventListener('click', (e) => {
            if (state.tool !== 'text') return;
            if (e.target !== els.textLayer) return;
            const rect = els.textLayer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            addAnnotation(state.pageNum, x, y, "輸入文字...", annoColor, annoFont, annoSize);
            setTool('cursor');
        });

        function addAnnotation(pageNum, x, y, content, color = '#222222', font = 'Inter', size = 16) {
            if (!state.annotations[pageNum - 1]) state.annotations[pageNum - 1] = [];
            state.annotations[pageNum - 1].push({ x, y, content, color, font, size });
            createTextInput(x, y, content, state.annotations[pageNum - 1].length - 1, true, color, font, size);
        }

        function createTextInput(x, y, content, index, focus = false, color = '#222222', font = 'Inter', size = 16) {
            const input = document.createElement('div');
            input.contentEditable = true;
            input.className = 'draggable-text pointer-events-auto';
            input.style.left = `${x}px`;
            input.style.top = `${y}px`;
            input.innerText = content;
            input.style.color = color;
            input.style.fontFamily = font;
            input.style.fontSize = `${size}px`;

            // 更新內容與屬性
            input.addEventListener('input', () => {
                if (state.annotations[state.pageNum - 1][index]) {
                    state.annotations[state.pageNum - 1][index].content = input.innerText;
                }
            });
            input.addEventListener('blur', () => {
                if (state.annotations[state.pageNum - 1][index]) {
                    state.annotations[state.pageNum - 1][index].color = input.style.color;
                    state.annotations[state.pageNum - 1][index].font = input.style.fontFamily;
                    state.annotations[state.pageNum - 1][index].size = parseInt(input.style.fontSize);
                }
            });

            // 拖曳
            let isDragging = false;
            let startX, startY, initialLeft, initialTop;
            input.addEventListener('mousedown', (e) => {
                if (state.tool !== 'cursor') return;
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialLeft = parseInt(input.style.left || 0);
                initialTop = parseInt(input.style.top || 0);
                input.style.borderColor = '#6366F1';
            });
            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                const newX = initialLeft + dx;
                const newY = initialTop + dy;
                input.style.left = `${newX}px`;
                input.style.top = `${newY}px`;
                if (state.annotations[state.pageNum - 1][index]) {
                    state.annotations[state.pageNum - 1][index].x = newX;
                    state.annotations[state.pageNum - 1][index].y = newY;
                }
            });
            window.addEventListener('mouseup', () => {
                isDragging = false;
                if (input) input.style.borderColor = 'transparent';
            });
            els.textLayer.appendChild(input);
            if (focus) {
                setTimeout(() => {
                    input.focus();
                    document.execCommand('selectAll', false, null);
                }, 0);
            }
        }

        // --- 繪圖功能 ---
        // --- 繪圖工具選單 ---
        const drawToolbar = document.createElement('div');
        drawToolbar.id = 'draw-toolbar';
        drawToolbar.className = 'fixed top-36 left-1/2 -translate-x-1/2 z-[90] bg-vibe-surface border border-vibe-border rounded-xl shadow-lg px-4 py-2 flex items-center gap-3';
        drawToolbar.innerHTML = `
            <label>筆色 <input type="color" id="draw-color" value="#ef4444" class="w-8 h-8 border rounded"></label>
            <label>粗細 <input type="number" id="draw-width" min="1" max="20" value="3" class="w-16 border rounded px-2 py-1"></label>
            <button id="draw-eraser" class="px-3 py-1 rounded border border-vibe-border bg-gray-200 text-black">橡皮擦</button>
        `;
        document.body.appendChild(drawToolbar);
        let drawColor = '#ef4444', drawWidth = 3, drawEraser = false;
        drawToolbar.querySelector('#draw-color').oninput = e => { drawColor = e.target.value; drawCtx.strokeStyle = drawColor; };
        drawToolbar.querySelector('#draw-width').oninput = e => { drawWidth = parseInt(e.target.value); drawCtx.lineWidth = drawWidth; };
        drawToolbar.querySelector('#draw-eraser').onclick = () => { drawEraser = !drawEraser; drawCtx.strokeStyle = drawEraser ? '#fff' : drawColor; };

        drawCtx.lineWidth = drawWidth;
        drawCtx.lineJoin = 'round';
        drawCtx.lineCap = 'round';
        drawCtx.strokeStyle = drawColor;

        els.drawCanvas.addEventListener('mousedown', (e) => {
            if (state.tool !== 'draw') return;
            state.isDrawing = true;
            drawCtx.lineWidth = drawWidth;
            drawCtx.strokeStyle = drawEraser ? '#fff' : drawColor;
            [state.lastX, state.lastY] = [e.offsetX, e.offsetY];
        });

        els.drawCanvas.addEventListener('mousemove', (e) => {
            if (!state.isDrawing || state.tool !== 'draw') return;
            drawCtx.beginPath();
            drawCtx.moveTo(state.lastX, state.lastY);
            drawCtx.lineTo(e.offsetX, e.offsetY);
            drawCtx.stroke();
            [state.lastX, state.lastY] = [e.offsetX, e.offsetY];
        });

        const stopDrawing = () => {
            if (state.isDrawing) {
                state.isDrawing = false;
                // 保存當前頁面的筆跡
                state.drawings[state.pageNum - 1] = els.drawCanvas.toDataURL();
            }
        };
        els.drawCanvas.addEventListener('mouseup', stopDrawing);
        els.drawCanvas.addEventListener('mouseout', stopDrawing);

        // --- 頁面控制 ---
        async function changePage(offset) {
            // 移除非法 return，duplicatePage 已結束
            const newNum = state.pageNum + offset;
            if (newNum >= 1 && newNum <= state.pdfJsDoc.numPages) {
                // 切換前先強制保存當前頁面的筆跡（防呆）
                state.drawings[state.pageNum - 1] = els.drawCanvas.toDataURL();
                await renderPage(newNum);
                pushHistory();
            }
        }

        function getCurrentPageIndex() {
            return state.pageNum - 1;
        }

        function arrayMove(arr, fromIndex, toIndex) {
            const updated = [...arr];
            const [item] = updated.splice(fromIndex, 1);
            updated.splice(toIndex, 0, item);
            return updated;
        }

        function computeNewIndex(currentIndex, fromIndex, toIndex) {
            if (currentIndex === fromIndex) return toIndex;
            if (fromIndex < toIndex && currentIndex > fromIndex && currentIndex <= toIndex) return currentIndex - 1;
            if (fromIndex > toIndex && currentIndex >= toIndex && currentIndex < fromIndex) return currentIndex + 1;
            return currentIndex;
        }

        async function rebuildPdfJsDoc(targetPageNum) {
            const pdfBytes = await state.pdfDoc.save();
            state.pdfBytes = pdfBytes;
            state.pdfJsDoc = await pdfjsLib.getDocument(pdfBytes).promise;
            els.pageCount.textContent = state.pdfJsDoc.numPages;
            await renderPage(targetPageNum);
        }

        async function buildPageList() {
            // ...existing code...
        }

        // 頁面合併
        async function mergeSelectedPages() {
            const selected = Array.from(els.pageList.querySelectorAll('.page-item.selected'));
            if (selected.length < 2) { showToast('請選擇兩頁以上進行合併', 'error'); return; }
            const indices = selected.map(item => parseInt(item.dataset.index));
            // 合併內容：將後面頁的內容繪製到第一頁
            const baseIdx = indices[0];
            const basePage = state.pdfDoc.getPages()[baseIdx];
            for (let i = 1; i < indices.length; i++) {
                const page = state.pdfDoc.getPages()[indices[i]];
                const { width, height } = page.getSize();
                // 將頁面渲染為圖片再嵌入
                // 這裡簡化為刪除後面頁
                state.pdfDoc.removePage(indices[i]);
            }
            await rebuildPdfJsDoc(baseIdx + 1);
            await buildPageList();
            showToast('合併完成', 'success');
        }

        // 頁面分割
        async function splitPage() {
            const idx = getCurrentPageIndex();
            const page = state.pdfDoc.getPages()[idx];
            const { width, height } = page.getSize();
            // 分割為兩頁（簡化為複製一頁）
            const newPage = state.pdfDoc.insertPage(idx + 1, [width, height]);
            await rebuildPdfJsDoc(idx + 1);
            await buildPageList();
            showToast('分割完成（複製一頁）', 'success');
        }

        // 頁面複製
        async function duplicatePage() {
            const idx = getCurrentPageIndex();
            const page = state.pdfDoc.getPages()[idx];
            const { width, height } = page.getSize();
            const newPage = state.pdfDoc.insertPage(idx + 1, [width, height]);
            // 可進階複製內容
            await rebuildPdfJsDoc(idx + 1);
            await buildPageList();
            showToast('複製完成', 'success');
        }

        // buildPageList 應為獨立 function，修正語法錯誤
        async function buildPageList() {
            if (!state.pdfJsDoc) return;
            els.pageList.innerHTML = '';
            const total = state.pdfJsDoc.numPages;
            for (let i = 0; i < total; i++) {
                const pageNumber = i + 1;
                const item = document.createElement('div');
                item.className = 'page-item rounded-xl p-3 bg-vibe-surface border border-vibe-border hover:border-indigo-400/40 transition-colors flex items-center gap-2';
                item.dataset.index = i;
                item.draggable = true;
                // 多選勾選框
                const checkbox = document.createElement('input');
                // ...existing code...
            }
        }
        checkbox.type = 'checkbox';
        checkbox.className = 'mr-2';
        checkbox.onchange = () => {
            item.classList.toggle('selected', checkbox.checked);
            updateMultiPreview();
        };
        item.appendChild(checkbox);
        const header = document.createElement('div');
        header.className = 'flex-1 flex items-center justify-between text-sm text-gray-300 mb-2';
        header.innerHTML = `<span>第 ${pageNumber} 頁</span>`;
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'text-gray-400 hover:text-red-400';
        deleteBtn.innerHTML = '<i class="ph ph-trash"></i>';
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            deletePageAt(i);
        });
        header.appendChild(deleteBtn);
        const canvas = document.createElement('canvas');
        canvas.className = 'w-full rounded-md shadow';
        item.appendChild(header);
        item.appendChild(canvas);
        item.addEventListener('click', () => {
            renderPage(pageNumber);
        });
        // 拖曳動畫
        let dragSrcIndex = null;
        item.addEventListener('dragstart', (e) => {
            item.classList.add('opacity-70');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', String(i));
            dragSrcIndex = i;
        });
        item.addEventListener('dragend', () => {
            item.classList.remove('opacity-70');
            dragSrcIndex = null;
            // 移除所有動畫
            els.pageList.querySelectorAll('.page-item').forEach(it => {
                it.style.transition = '';
                it.style.transform = '';
            });
        });
        item.addEventListener('dragover', (e) => {
            e.preventDefault();
            item.classList.add('drag-over');
            // 動畫效果：目標項目向下/上移
            const toIndex = Number(item.dataset.index);
            els.pageList.querySelectorAll('.page-item').forEach((it, idx) => {
                it.style.transition = 'transform 0.2s cubic-bezier(.4,2,.6,1)';
                if (dragSrcIndex !== null) {
                    if (idx === toIndex) {
                        it.style.transform = `scale(1.05) translateY(${dragSrcIndex < toIndex ? '-8px' : '8px'})`;
                    } else if (idx === dragSrcIndex) {
                        it.style.transform = `scale(0.98) translateY(${dragSrcIndex < toIndex ? '8px' : '-8px'})`;
                    } else {
                        it.style.transform = '';
                    }
                }
            });
        });
        item.addEventListener('dragleave', () => {
            item.classList.remove('drag-over');
            // 移除動畫
            els.pageList.querySelectorAll('.page-item').forEach(it => {
                it.style.transition = '';
                it.style.transform = '';
            });
        });
        item.addEventListener('drop', async (e) => {
            e.preventDefault();
            item.classList.remove('drag-over');
            // 移除動畫
            els.pageList.querySelectorAll('.page-item').forEach(it => {
                it.style.transition = '';
                it.style.transform = '';
            });
            const fromIndex = Number(e.dataTransfer.getData('text/plain'));
            const toIndex = Number(item.dataset.index);
            if (Number.isNaN(fromIndex) || fromIndex === toIndex) return;
            await reorderPages(fromIndex, toIndex);
        });
        els.pageList.appendChild(item);
        const page = await state.pdfJsDoc.getPage(pageNumber);
        const baseViewport = page.getViewport({ scale: 1 });
        const scale = 180 / baseViewport.width;
        const viewport = page.getViewport({ scale });
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const thumbCtx = canvas.getContext('2d');
        await page.render({ canvasContext: thumbCtx, viewport }).promise;
        }
        updateActivePageInList();
        updateMultiPreview();
        }

        // 多頁同時預覽
        function updateMultiPreview() {
            const selected = Array.from(els.pageList.querySelectorAll('.page-item.selected'));
            const main = document.getElementById('main-scroll');
            // 移除舊多頁預覽
            main.querySelectorAll('.multi-preview').forEach(e => e.remove());
            if (selected.length <= 1) return;
            selected.forEach(item => {
                const idx = parseInt(item.dataset.index);
                const preview = document.createElement('div');
                preview.className = 'multi-preview absolute top-0 left-0 w-full h-full flex items-center justify-center z-30';
                preview.style.background = 'rgba(30,34,43,0.85)';
                preview.innerHTML = `<div class='flex flex-wrap gap-8 p-8'>${selected.map((it, i) => {
                    const canvas = it.querySelector('canvas');
                    return `<div class='bg-white rounded-xl shadow-lg border border-vibe-border p-2'><canvas width='${canvas.width}' height='${canvas.height}' style='width:220px;height:auto'></canvas><div class='text-center text-sm mt-2'>第 ${parseInt(it.dataset.index) + 1} 頁</div></div>`;
                }).join('')}</div>`;
                main.appendChild(preview);
                // 複製縮圖到預覽
                const previewCanvases = preview.querySelectorAll('canvas');
                selected.forEach((it, i) => {
                    const srcCanvas = it.querySelector('canvas');
                    const destCanvas = previewCanvases[i];
                    destCanvas.getContext('2d').drawImage(srcCanvas, 0, 0);
                });
            });
        }

        function updateActivePageInList() {
            const items = els.pageList.querySelectorAll('.page-item');
            items.forEach((item) => {
                const index = Number(item.dataset.index);
                if (index === state.pageNum - 1) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        async function reorderPages(fromIndex, toIndex) {
            if (!state.pdfDoc) return;
            const currentIndex = getCurrentPageIndex();
            state.pdfDoc.movePage(fromIndex, toIndex);
            state.annotations = arrayMove(state.annotations, fromIndex, toIndex);
            state.drawings = arrayMove(state.drawings, fromIndex, toIndex);
            const newIndex = computeNewIndex(currentIndex, fromIndex, toIndex);
            await rebuildPdfJsDoc(newIndex + 1);
            await buildPageList();
        }

        async function insertBlankPage() {
            if (!state.pdfDoc) return;
            const currentIndex = getCurrentPageIndex();
            const currentPage = state.pdfDoc.getPages()[currentIndex];
            const size = currentPage ? currentPage.getSize() : { width: 595.28, height: 841.89 };
            const insertIndex = currentIndex + 1;
            state.pdfDoc.insertPage(insertIndex, [size.width, size.height]);
            state.annotations.splice(insertIndex, 0, []);
            state.drawings.splice(insertIndex, 0, null);
            await rebuildPdfJsDoc(insertIndex + 1);
            await buildPageList();
            pushHistory();
        }

        function triggerImageInsert() {
            if (!state.pdfDoc) return;
            els.imageInsert.value = '';
            els.imageInsert.click();
        }

        els.imageInsert.addEventListener('change', async (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            if (!['image/png', 'image/jpeg'].includes(file.type)) {
                showToast('只支援 PNG 或 JPG', 'error');
                return;
            }
            await insertImagePage(file);
        });

        async function insertImagePage(file) {
            if (!state.pdfDoc) return;
            const currentIndex = getCurrentPageIndex();
            const insertIndex = currentIndex + 1;

            const arrayBuffer = await file.arrayBuffer();
            const image = file.type === 'image/png'
                ? await state.pdfDoc.embedPng(arrayBuffer)
                : await state.pdfDoc.embedJpg(arrayBuffer);

            const imageWidth = image.width;
            const imageHeight = image.height;
            const page = state.pdfDoc.insertPage(insertIndex, [imageWidth, imageHeight]);
            page.drawImage(image, {
                x: 0,
                y: 0,
                width: imageWidth,
                height: imageHeight
            });

            state.annotations.splice(insertIndex, 0, []);
            state.drawings.splice(insertIndex, 0, null);

            await rebuildPdfJsDoc(insertIndex + 1);
            await buildPageList();
        }

        async function rotatePage() {
            if (!state.pdfDoc) return;
            const page = state.pdfDoc.getPages()[state.pageNum - 1];
            const currentRotation = page.getRotation().angle;
            page.setRotation(PDFLib.degrees(currentRotation + 90));
            els.pdfWrapper.style.transition = 'transform 0.3s';
            showToast('頁面已旋轉（匯出時生效）', 'info');
            pushHistory();
        }

        async function deletePage() {
            if (!state.pdfDoc) return;
            deletePageAt(getCurrentPageIndex());
            pushHistory();
        }

        async function deletePageAt(pageIndex) {
            if (!state.pdfDoc) return;
            if (state.pdfDoc.getPageCount() <= 1) {
                showToast('至少需要保留 1 頁', 'warning', 3000, 'ph-warning-circle');
                return;
            }
            if (confirm('確定要刪除此頁嗎？')) {
                state.pdfDoc.removePage(pageIndex);
                state.annotations.splice(pageIndex, 1);
                state.drawings.splice(pageIndex, 1);
                const newPageNum = Math.min(pageIndex + 1, state.pdfDoc.getPageCount());
                await rebuildPdfJsDoc(newPageNum);
                await buildPageList();
                showToast('已刪除頁面', 'success');
                pushHistory();
            }
        }

        // --- 壓縮功能 ---
        function openCompressModal() {
            if (!state.pdfDoc) return;
            els.compressModal.classList.remove('hidden');
            els.compressModal.classList.add('flex');
            const isRaster = els.compressMode.value === 'raster';
            els.compressScale.disabled = !isRaster;
            els.compressQuality.disabled = !isRaster;
            // 顯示密碼欄位
            if (!document.getElementById('compress-password')) {
                const pwdDiv = document.createElement('div');
                pwdDiv.className = 'mt-4 flex items-center gap-2';
                pwdDiv.innerHTML = `<label class='text-sm text-vibe-text'>PDF密碼：</label><input id='compress-password' type='password' class='px-3 py-2 rounded border border-vibe-border bg-white text-black dark:bg-vibe-surface dark:text-vibe-text' placeholder='輸入密碼（可選）'>`;
                els.compressModal.querySelector('.flex-col')?.appendChild(pwdDiv);
            }
        }

        function closeCompressModal() {
            els.compressModal.classList.add('hidden');
            els.compressModal.classList.remove('flex');
        }

        async function buildEditedPdfBytes() {
            const baseBytes = await state.pdfDoc.save();
            const tempDoc = await PDFLib.PDFDocument.load(baseBytes);
            const pages = tempDoc.getPages();

            for (let i = 0; i < pages.length; i++) {
                const page = pages[i];
                const { width, height } = page.getSize();

                const annos = state.annotations[i] || [];
                for (const anno of annos) {
                    const pdfX = anno.x / state.scale;
                    const pdfY = height - (anno.y / state.scale) - 12;
                    page.drawText(anno.content, {
                        x: pdfX,
                        y: pdfY,
                        size: 16 / state.scale * 1.5,
                        color: PDFLib.rgb(0, 0, 0),
                    });
                }

                const drawingDataUrl = state.drawings[i];
                if (drawingDataUrl) {
                    const pngImage = await tempDoc.embedPng(drawingDataUrl);
                    page.drawImage(pngImage, {
                        x: 0,
                        y: 0,
                        width: width,
                        height: height,
                    });
                }
            }

            return await tempDoc.save();
        }

        async function compressPdf() {
            if (!state.pdfDoc) return;

            const mode = els.compressMode.value;
            const scale = Number(els.compressScale.value);
            const quality = Number(els.compressQuality.value);
            const password = document.getElementById('compress-password')?.value || '';

            els.compressAction.disabled = true;
            els.compressAction.textContent = '壓縮中...';
            showLoading('PDF 壓縮中...');

            try {
                const editedBytes = await buildEditedPdfBytes();
                let compressedBytes;
                if (mode === 'lossless') {
                    const losslessDoc = await PDFLib.PDFDocument.load(editedBytes);
                    compressedBytes = await losslessDoc.save({ useObjectStreams: true });
                } else {
                    const pdfJsDoc = await pdfjsLib.getDocument({ data: editedBytes }).promise;
                    const compressedDoc = await PDFLib.PDFDocument.create();
                    for (let i = 1; i <= pdfJsDoc.numPages; i++) {
                        const page = await pdfJsDoc.getPage(i);
                        const viewport = page.getViewport({ scale });
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = Math.floor(viewport.width);
                        canvas.height = Math.floor(viewport.height);
                        await page.render({ canvasContext: context, viewport }).promise;
                        const jpegDataUrl = canvas.toDataURL('image/jpeg', quality);
                        const jpegImage = await compressedDoc.embedJpg(jpegDataUrl);
                        const compressedPage = compressedDoc.addPage([viewport.width, viewport.height]);
                        compressedPage.drawImage(jpegImage, {
                            x: 0,
                            y: 0,
                            width: viewport.width,
                            height: viewport.height
                        });
                    }
                    compressedBytes = await compressedDoc.save({ useObjectStreams: true });
                }
                // PDF加密（簡易密碼保護）
                let finalBytes = compressedBytes;
                if (password) {
                    // PDF-Lib不支援加密，故此處可用jsPDF或外部API（此為前端沙盒，僅示範UI流程）
                    showToast('前端加密僅示意，請用專業工具加密PDF', 'warning', 4000, 'ph-lock');
                }
                const blob = new Blob([finalBytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = password ? 'vibe-compressed-encrypted.pdf' : 'vibe-compressed.pdf';
                link.click();
                closeCompressModal();
                showToast(password ? '壓縮並加密完成，已下載檔案' : '壓縮完成，已下載檔案', 'success');
            } catch (error) {
                console.error(error);
                showToast('壓縮失敗，請稍後再試', 'error');
            } finally {
                els.compressAction.disabled = false;
                els.compressAction.textContent = '開始壓縮';
                hideLoading();
            }
        }

        // --- 匯出功能 ---
        async function downloadPdf() {
            if (!state.pdfDoc) return;

            showLoading('PDF 產生中...');
            // 1. 將所有的標註寫入 PDF
            const pages = state.pdfDoc.getPages();

            for (let i = 0; i < pages.length; i++) {
                const pageNum = i + 1;
                const page = pages[i];
                const { width, height } = page.getSize();

                // 處理文字
                const annos = state.annotations[i] || [];
                for (const anno of annos) {
                    // 座標轉換：HTML Canvas (Top-Left 0,0) -> PDF (Bottom-Left 0,0)
                    // 需要根據 scale 還原比例
                    const pdfX = anno.x / state.scale;
                    // PDF Y 軸是倒過來的，且需考慮字體大小的位移
                    const pdfY = height - (anno.y / state.scale) - 12; // 12 是字體高度估算

                    page.drawText(anno.content, {
                        x: pdfX,
                        y: pdfY,
                        size: 16 / state.scale * 1.5, // 簡單的字體比例調整
                        color: PDFLib.rgb(0, 0, 0),
                    });
                }

                // 處理繪圖
                const drawingDataUrl = state.drawings[i];
                if (drawingDataUrl) {
                    // 將 DataURL 轉為 PDFImage
                    const pngImage = await state.pdfDoc.embedPng(drawingDataUrl);
                    page.drawImage(pngImage, {
                        x: 0,
                        y: 0,
                        width: width,
                        height: height,
                    });
                }
            }

            const pdfBytes = await state.pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'vibe-edited.pdf';
            link.click();
            hideLoading();
            showToast('已匯出 PDF 檔案', 'success');
        }

    </script>
</body>

</html>